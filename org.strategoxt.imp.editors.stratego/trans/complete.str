module complete

imports
  analysis
  libstrc
  editor-common.generated


strategies
  
  editor-complete:
    (v@Var(COMPLETION(_)), position, ast, path, project-path) -> proposals
    with
      <analyze-ast-local> ast;
      proposals := <get-completion-proposals> v
      
  editor-complete:
    (sv@SVar(COMPLETION(_)), position, ast, path, project-path) -> proposals
    with
      <analyze-ast-local> ast;
      proposals := <get-completion-proposals> sv 

  editor-complete:
    (dr@DynRuleScopeId(COMPLETION(_)), position, ast, path, project-path) -> proposals
    where
      proposals := <get-completion-proposals> dr 

  editor-complete:
    (rd@RDecT(COMPLETION(_), _, _), position, ast, path, project-path) -> proposals
    where
      proposals := <get-completion-proposals> rd //Completion support for adding a dynamic rule

  editor-complete:
    (Import(COMPLETION(_)), position, ast, path, project-path) -> proposals
    where
      proposals := <imported-module-name-proposals> ast

  editor-complete:
    (Module(COMPLETION(_), _), position, ast, path, project-path) -> proposals
    where
      proposals := <new-module-name-proposals> path

  editor-complete:
    (SortVar(COMPLETION(_)), position, ast, path, project-path) -> proposals
    where
      proposals := [] //TODO
 


rules //helpers
  
  get-completion-proposals :
    cn@completion-node -> proposals
    where
      //Fallback in case analysis fails, only global vars are shown
      proposals := <ContentProposals <+ <propose-completion> cn <+ ![]> 

  imported-module-name-proposals:
    ast -> proposals'
    where
      proposals := <all-keys-ModuleName>;
      excluded-proposals :=
        [<?Module(<id>,_)> ast | <collect-all(?Import(<id>))> ast];
      proposals':= <diff> (proposals, excluded-proposals)

  new-module-name-proposals:
    path -> proposals
    where
      proposals := [
        <base-filename; remove-extension> path,
        <remove-extension> path
      ]
