module rename

imports
  analysis
  libstrc
  desugar
  sourcedir
  lib/editor-common.generated
  lib-refactoring/rename-generic
  lib-refactoring/files
  lib-refactoring/language-description

rules //rename refactoring, builder
  
  rename-builder:
  (selected, position, ast, path, project-path) -> (filename, resulting-asts)
  where
  	resulting-asts := <rename-refactoring; map(Snd)>;
    filename := <guarantee-extension(|"aterm")> path  

  rename-refactoring:
    (selected, position, ast, path, project-path) -> ast-change-tuples
    where
      init-analysis;
      save-all-resources;
      (ref-name, ast') := <get-analysed-terms(analyse-names)> (selected, ast);
      newname := <dialog-newname(|<get-language-name> path)>;
      asts := <collect-affected-asts>(ref-name, newname, ast', $[[<project-path>]/[path]]);
      report-precondition-issues(!asts; precondition-error(|ref-name));
      ast-change-tuples := <apply-rename-refactoring(
      	re-analyse-names, 
      	collect-sem-errors |
      	ref-name,
      	newname
      )> asts
 
rules //precondition checks

//TODO: better solution?	
//FIXME: no declaration outside asts (lib or generated), since these files are not changed
//NOW: a declaration in asts exists
precondition-error(|ref-name):
	asts -> ([$[Declaration can not be found in [<project-path>]/trans]],[])
	where
	  <?_{ref}> ref-name; 
	  <is-global-ref> ref; 
	  decl := <Declaration> ref; 
	  <not(topdown(strip-annos); oncetd(equal(|decl)))> asts

rules //name analysis
    
  analyse-names:
  	asts -> <analyse-names-asts> desugared-asts
    where
       desugared-asts := <map(basic-desugar-top)> asts;
       <declare-globals> Import("libstratego-lib"); //Import external strategy definitions
       <map( //Import strategy definitions from files that are not in the list
           alltd(
           	 is-not-imported-from-list(|asts);
             declare-globals
           )
       )> desugared-asts
  
  is-not-imported-from-list(|asts) =
    where(?Import(mod) <+ ?ImportWildcard(mod)); 
    where(not(<fetch(?Module(mod, _))> asts))
  
  re-analyse-names =
    topdown(strip-annos);
    topdown(try(resugar-Let)); //TODO: better solution?
    analyse-names-asts
  
  analyse-names-asts:
    asts -> asts'
    where
       asts' := < //re-analyze affected asts
         map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
         map(declare-bodies-top)
       > asts

  resugar-Let:
  	Rec(x, y) -> Let(x,y)
  	where 
  	  origin-term; 
  	  ?Let(_, _)

  init-analysis =
       rules(
          CurrentFile := "" //TODO: primitive for file path?
          ProjectDir  := <project-path>
       );
       try(get-source-base-dir)

rules //semantic constraint check

  collect-sem-errors = 
    where (errors :=<collect-all(global-constraint-error + constraint-error, conc)>);
    where (warnings :=<collect-all(constraint-warning, conc)>);
    <conc>(errors, warnings);
    flatten-list
	
rules //collect asts that are possibly affected by renaming, efficient implementation using cache

//1. do not collect files when selected var is local ##
//2. for global vars: 
//2a. keep editor ast to be more robust in case of syntax errors ##
//2b. collect only the files that are relevant ## 
//2c. use cache to reject files before analyzing ##
//2d. parallel with user input dialog
//2e. (?) collect files in loop instead of by map(parse)?
//3. re-analyzes: keep lookup tables, no normalization, no external import ##
 
collect-affected-asts:
	(oldname{ref}, newname, ast, path-to-ast) -> [ast|<analyse-names> affected-asts]
	where
  	  if <is-global-ref> ref then //files are only collected if the selected var is global 
  	  	//save-all-resources;
	    fnames := <get-source-files(
		  has-extension(|"str"); not(equal(|path-to-ast)), //exclude current ast which is obtained from the editor (allowing parse errors) 
		  not(fail)
	    )> $[[<project-path>]/trans]; 
	    (fnames-cache, fnames-no-cache) := <partition-by-cache(|oldname)> fnames;
	    asts-no-cache := <parse-source-files(parse-file)> fnames-no-cache; //TODO: parallel with rename dialog?!
	    asts-filtered-no-cache := <filter(
	    	oncetd(equal(|newname) <+ equal(|<strip-annos> oldname))
	    )> asts-no-cache;
	    asts-filtered-cache := <filter(ReadFromFile; oncetd(equal(|newname)))> fnames-cache; 
	    affected-asts := <conc>(asts-filtered-no-cache, asts-filtered-cache)
      else
      	affected-asts := []
      end

is-global-ref =
	where(
		?ref;
		<Declaration; signature-of; DeclareCookie; equal(|ref)> ref
	)

partition-by-cache(|refname):
	fnames -> 
		<partition(
			get-cache-path;
			where(
				ReadFromFile; 
				not(oncetd(equal(|<strip-annos> refname))) //exclude files that will change
			)
		)> fnames
		
	
get-cache-path: //asts without endangered names can be ignored
	path -> cache-path
	where(
  	  cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
  	  <is-newer> (cache-path, path)
  	)
