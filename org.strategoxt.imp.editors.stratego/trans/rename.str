module rename

imports
  analysis
  libstrc
  desugar
  sourcedir
  lib/editor-common.generated
  lib-refactoring/generic-rename
  lib-refactoring/files
  lib-refactoring/fetch

rules //rename refactoring

  rename-refactoring:
    (newname, selected, position, ast, path, project-path) -> 
    (ast-changes, [], <conc> (pre-condition-errors, semantic-errors), warnings)
    where 
      (renamings, asts, pre-condition-errors)  := <prepare-renaming> (newname, selected, ast, path);
      (ast-changes, semantic-errors, warnings) := <apply-rename-refactoring(
        re-analyse-names, 
        collect-semantic-issues |
        renamings
      )> asts;
      editor-init //analysis must be redone in case refactoring is canceled

  prepare-renaming:
    (newname, selected, ast, path) -> (renamings, asts, <conc>(parse-errors, ext-def-errors))
    where
      (name{ref}, ast') := <annotated-terms(analyze-names-ensure-imports)> (selected, ast); 
      renamings := <get-dependend-renamings> (name{ref}, newname);
      (asts, unparsable-files) := <collect-affected-asts>(ref, renamings, ast', $[[<project-path>]/[path]]);
      parse-errors := <map(!$[parsing failed for: '[<id>]'])> unparsable-files;
      ext-def-errors := <external-declaration-error> ref 
      
rules //dependent names
    
  get-dependend-renamings:
    r@(refname, newname) -> renamings
    where
      <?_{ref}> refname;
      if <Declaration; ?RDecT(oldname, _, _)> ref then 
        old-names := <prefixes-dynrules; map(!$[[<id>]-[oldname]]{ref})>;
        new-names := <prefixes-dynrules; map(!$[[<id>]-[newname]]{ref})>;
        renamings := [(oldname{ref}, newname)|<zip>(old-names, new-names)]
      else
        renamings := [r]
      end

  prefixes-dynrules =
    !["once", "bagof", "bigbagof", "all-keys", "innermost-scope", "break", "break-bp", 
      "continue", "chain", "bigchain", "new", "undefine", "aux", "reverse-bagof", "innermost-scope",
      "break-to-label","continue-to-label", "throw", "fold", "bigfold"]
  
rules //name analysis
    
  analyze-names-ensure-imports:
    asts -> <analyze-names> desugared-asts
    where
      rules(CurrentFile := "" ProjectDir  := <project-path>);
      try(get-source-base-dir);
      desugared-asts := <map(basic-desugar-top)> asts;
      <declare-globals> Import("libstratego-lib");
      <map(alltd(is-not-imported-from-asts(|asts); declare-globals))> desugared-asts
  
  is-not-imported-from-asts(|asts) =
    where(?Import(mod) <+ ?ImportWildcard(mod)); 
    where(not(<fetch(?Module(mod, _))> asts))
    
  analyze-names:
    asts -> asts'
    where
      asts' := < //re-analyze affected asts
        map(alltd(where(not(?Import(_) <+ ?ImportWildcard(_))); declare-globals)); //external imports already done 
        map(declare-bodies-top)
      > asts

  re-analyse-names =
    topdown(strip-annos);
    topdown(try(resugar-Let)); //TODO: better solution?
    analyze-names

  resugar-Let:
    Rec(x, y) -> Let(x,y) where origin-term; ?Let(_, _)

rules //semantic constraint check

  collect-semantic-issues:
    ast -> (errors, warnings)
    where 
      errors := <collect-all(global-constraint-error + constraint-error, conc)> ast;
      warnings := <collect-all(constraint-warning, conc)> ast
  
rules //collect asts that are possibly affected by renaming, efficient implementation using cache
 
  collect-affected-asts:
    (ref-anno, renamings, ast, path-to-ast) -> ([ast|<analyze-names-ensure-imports> affected-asts], unparsable-files)
    where
      if <is-global-ref> ref-anno then //files are only collected if the selected var is global 
        fnames := <get-stratego-files; filter(is-editable; not(equal(|path-to-ast)))>; 
        (affected-asts, unparsable-files) := 
          <get-affected-asts(oncetd(is-endangered-name(|renamings)), get-cache-path)> fnames
      else
        affected-asts := [];
        unparsable-files := []
      end

  is-global-ref =
    where(?ref; <Declaration; signature-of; DeclareCookie; equal(|ref)> ref)    

  get-stratego-files =
    project-path;
    get-source-files(
      has-extension(|"str"), 
      not(is-spoofax-dir) <+ equal(|$[[<project-path>]/trans]) <+ equal(|$[[<project-path>]/include])
    ) 

  is-editable = 
    not(string-ends-with(|".generated.str"));
    not(dirname; string-ends-with(|"include"))

  get-cache-path: 
    path -> cache-path
    where
      cache-path := <import-cache-path; string-replace(|".str.sig", ".rtree")> path; 
      <is-newer> (cache-path, path)
    
rules //precondition checks on imported files

  external-declaration-error:
    ref -> <conc> (generated-file-errors, lib-errors)
    where 
      generated-file-errors := <get-stratego-files; filter(declared-in-generated-file(|ref))>; 
      lib-errors := <![<declared-in-lib>] <+ ![]> ref

  declared-in-generated-file(|ref):
    fname -> $[Name in [<base-filename>] can not be edited]
    where
  	  not(is-editable);
      (((import-cache-path <+ get-cache-path); ReadFromFile) <+ parse-file);
      declare-globals-top; 
      oncetd(?_{ref})

  declared-in-lib:
    ref -> $[External declaration can not be edited]
    where
      <Declaration; get-constructor; string-starts-with(|"Ext")> ref