module spectrav

imports
  
  include/Stratego-Sugar
  lib/runtime/nabl/utils
  
rules
  
  generate-specific-traversal:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"traversal.str")> path;
      result   := <gen-spectrav-module> ast
  
rules
  
  gen-spectrav-module:
    Module(m, decl*) -> 
    $[module [m].traversal
      
      imports
        
        [m]
        lib/nabl/-
        lib/properties/-
        lib/editor/-
      
      rules // Debugging
      	
      	spectrav-debug(|msg) = fail
      
      rules // Built-ins
        
        [<gen-generic> "Int"]
        [<specific-collect-name> "Int"] = match(sibling-uris|uri*)
        [<gen-generic> "String"]
        [<specific-collect-name> "String"] = match(sibling-uris|uri*)
      
      rules // Sibling list traversals
      	
      	[sib-list-trav]
      
      [traversal]]
    with
      sig*          := <collect-all(?Constructors(<id>)); concat> decl*;
      sib-list-trav := <filter(sig-sort-name); make-set; map(gen-sort-siblings); concat-strings> sig*;
      traversal     := <filter(gen-spectrav); concat-strings> sig*

rules
	
	sig-sort-name: OpDeclInj(FunType(_, ConstType(SortNoArgs(sort-name)))) -> sort-name
	sig-sort-name: OpDecl(_, ConstType(SortNoArgs(sort-name)))             -> sort-name
	sig-sort-name: OpDecl(_, FunType(_, ConstType(SortNoArgs(sort-name)))) -> sort-name
		 
rules
      
  gen-spectrav:
    OpDeclInj(FunType([inj-sort], sort@ConstType(SortNoArgs(_)))) -> 
    $[rules // Sort [sort-name], injected into [inj-sort-name]
      
        [<gen-generic> sort-name]
        
        [<specific-collect-name> sort-name] = [<specific-collect-name> inj-sort-name]
    
    ]
    with
      sort-name     := <sort-name> sort;
      inj-sort-name := <sort-name> inj-sort

      
  gen-spectrav:
    OpDecl(cons, sort@ConstType(SortNoArgs(_))) -> 
    $[rules // Constructor [cons-name], Sort [sort-name]
      
        [<gen-generic> sort-name]
    
        [<gen-sort(|cons-name)> sort-name]
      
        [<gen-constructor(|cons, 0, [])> sort-name]
      
    ]
    with
      sort-name   := <sort-name> sort;
      cons-name   := <cons-name(|0)> cons
    
  gen-spectrav:
    OpDecl(cons, FunType(sort-param*, sort@ConstType(SortNoArgs(_)))) ->
    $[rules // Constructor [cons-name], Sort [sort-name]
      
        [<gen-generic> sort-name]
    
        [<gen-sort(|cons-name)> sort-name]
      
        [<gen-constructor(|cons, cons-arity, sort-param*)> sort-name]
    
    ]
    with
      sort-name   := <sort-name> sort;
      cons-arity  := <length> sort-param*;
      cons-name   := <cons-name(|cons-arity)> cons

rules // Generic
  
  gen-generic:
    sort-name -> 
    $[[<generic-collect-name>] = [<specific-collect-name> sort-name]]
  
  
  collect-parameters = !"(sibling-uris|lang, partition, unique*, uri*)"
  generic-collect-name = !$[generic-collect[<collect-parameters>]]
  specific-collect-name:
    postfix -> $[specific-collect-[postfix][<collect-parameters>]]
  
  siblings-parameters = !"(|lang, partition, unique*, uri*)"
  specific-siblings-name:
    cons-name -> $[specific-siblings-[cons-name][<siblings-parameters>]]
  specific-siblings-list-name:
    sort-name -> $[specific-siblings-list-[sort-name][<siblings-parameters>]]

rules // Sorts
  
  sort-name: ConstType(SortNoArgs(sort)) -> sort
  sort-name: ConstType(Sort("List", [SortNoArgs(sort)])) -> sort
  sort-name: ConstType(Sort("Option", [SortNoArgs(sort)])) -> sort
  
  gen-sort(|cons-name):
    sort-name -> 
    ${{<specific-collect-name> sort-name} = {<specific-collect-name> cons-name}}
    
  gen-sort-siblings:
    sort-name -> 
    ${{<specific-siblings-list-name>} =
        []
      + [ specific-collect-{sort-name}(?sibling-uri*|lang, partition, unique*, uri*)
        | specific-siblings-list-{sort-name}(|lang, partition, unique*, sibling-uri*) ]
      
      specific-siblings-option-{sort-name}(sibling-uris|lang, partition, unique*, uri*) =
        (None(); match(sibling-uris|uri*))
      + Some(specific-collect-{sort-name}(?sibling-uris|lang, partition, unique*, uri*))
      + specific-collect-{sort-name}(?sibling-uris|lang, partition, unique*, uri*)
      
    }
    
rules // Constructors
  
  cons-name(|arity): cons -> $[[cons]-[arity]]
  
  gen-constructor(|cons, arity, sort-param*):
    sort-name ->
    ${specific-collect-{cons-name}(sibling-uris|lang, partition, unique*, uri*) =
        {cons-match} 
      ; nabl-state-pop(?state*)
      ; try({cons-name}-scoping-site)
      ; (
           nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
        <+ nabl-new-scope-site(?uri'*|lang, partition, unique*, uri*)
        <+ match(?uri'*|uri*) 
      ) 
      ; (
          {cons-name}-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
        ; try({cons-name}-new-scoping-site)
          <+ match(sibling-uris|uri*)
        ; match(?child-uri*|uri'*)
      )    
      ; try({cons-name}-state-site)
      ; try({cons-name}-collect-rewrite(|lang, partition, uri*, uri'*))
      {specific-siblings-call}
      ; try({cons-name}-external-def-site(|lang, partition, unique*, uri'*, state*, implicit*))
      ; try({cons-name}-use-site(|lang, partition, unique*, uri'*, state*))
      ; try({cons-name}-import-site(|lang, partition, unique*, child-uri*, state*))
      ; try({cons-name}-filtering-site(|lang, partition, unique*, uri*, state*))
      ; try({cons-name}-disambiguation-site(|lang, partition, unique*, uri*, state*))
      ; try({cons-name}-prop-site(|lang, partition, uri*, state*, implicit*))
      ; nabl-annotate-properties(|lang, partition, uri*, uri'*)
        
      {specific-siblings-def}
        
      {cons-name}-collect-rewrite(|lang, partition, old-uri*, new-uri*) = fail
      {cons-name}-scoping-site = fail
      {cons-name}-new-scoping-site = fail
      {cons-name}-def-site(child-uris, sibiling-uris, implicits| lang, partition, unique*, uri*, state*) = fail
      {cons-name}-external-def-site(|lang, partition, unique*, uri*, state*, implicit*) = fail
      {cons-name}-state-site = fail
      {cons-name}-use-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-filtering-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-disambiguation-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-import-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-prop-site(|lang, partition, uri*, state*, implicit*) = fail}
    with
    	cons-name  := <cons-name(|arity)> cons;
    	cons-match := <gen-constructor-match(|arity)> cons;
      if <gt> (<length> sort-param*, 0) then
        specific-siblings-call := ${; specific-siblings-{cons-name}(|lang, partition, unique*, uri*)};
        congruence-part-str    := <gen-specific-siblings-congruence; separate-by(|", "); concat-strings> sort-param*;
        specific-siblings-def  :=
          ${{<specific-siblings-name> cons-name} =
              spectrav-debug(|"a "); {cons}(
                {congruence-part-str}  
              ); spectrav-debug(|"b ")
          }
          // ${{<specific-siblings-name> cons-name} =
          //     preserve-annos(origin-track-forced(
          //       spectrav-debug(|"a "); {cons}(
          //         {congruence-part-str}  
          //       ); spectrav-debug(|"b ")
          //     ))
          //   
          // }
      else
        specific-siblings-call := "";
        specific-siblings-def  := ""
      end
  
  gen-constructor-match(|arity):
  	name -> $[?[name]([<repeat(!["_"|<id>]|arity); separate-by(!", ")> []])]
  
  gen-specific-siblings-congruence = gen-specific-siblings-congruence(|0, 0)
  
  gen-specific-siblings-congruence(|n, d):
    [sort, next-sort | sortz] -> [part-str | <gen-specific-siblings-congruence(|n', <inc> d)> [next-sort | sortz]]
    with
      (part-str, n') := <gen-specific-siblings-part(|n, d)> sort

  gen-specific-siblings-congruence(|n, d):
    [sort] -> [part-str]
    with
      (part-str, _) := <gen-specific-siblings-part(|n, d)> sort

  gen-specific-siblings-part(|n, d):
    _ -> ($[specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, uri*); spectrav-debug(|"[d] ")], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    where
      0 := n
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, sibling-uri-[<dec> n]*); spectrav-debug(|"[d] ")], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    where
      not(0 := n)
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[specific-siblings-option-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, uri*); spectrav-debug(|"[d] ")], <inc> n)
    where
      ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      0 := n
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[specific-siblings-option-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, sibling-uri-[<dec> n]*); spectrav-debug(|"[d] ")], <inc> n)
    where
      ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      not(0 := n)
    
  gen-specific-siblings-part(|n, d):
    ConstType(Sort("List", [SortNoArgs(sort-name)])) -> 
    ($[[<specific-siblings-list-name> sort-name]; spectrav-debug(|"[d] ")], n)

