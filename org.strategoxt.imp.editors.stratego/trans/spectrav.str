module spectrav

imports
  
  include/Stratego-Sugar
  lib/runtime/nabl/utils
  
rules
  
  generate-specific-traversal:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"traversal.str")> path;
      result   := <gen-spectrav-module> ast
  
rules
  
  gen-spectrav-module:
    Module(m, decl*) -> 
    $[module [m].traversal
      
      imports
        
        include/[m]
        lib/runtime/nabl/-
        lib/runtime/properties/-
      
      rules
        
        [<gen-generic> "Int"]
        [<specific-collect-name> "Int"] = id
        [<gen-generic> "String"]
        [<specific-collect-name> "String"] = id
      
      [traversal]]
    with
      sig*      := <collect-all(?Constructors(<id>)); concat> decl*;
      traversal := <filter(gen-spectrav); concat-strings> sig*

rules
      
  gen-spectrav:
    OpDeclInj(FunType([inj-sort], sort@ConstType(SortNoArgs(_)))) -> 
    $[rules
      
        [<gen-generic> sort-name]
        
        [<specific-collect-name> sort-name] = [<specific-collect-name> inj-sort-name]
        
        [<gen-sort-siblings> sort-name]
    
    ]
    with
      sort-name     := <sort-name> sort;
      inj-sort-name := <sort-name> inj-sort

      
  gen-spectrav:
    OpDecl(cons, sort@ConstType(SortNoArgs(_))) -> 
    $[rules
      
        [<gen-generic> sort-name]
    
        [<gen-sort(|cons-name)> sort-name]
      
        [<gen-constructor(|cons-name, cons, [])> sort-name]
      
    ]
    with
      sort-name   := <sort-name> sort;
      cons-name   := <cons-name(|0)> cons
    
  gen-spectrav:
    OpDecl(cons, FunType(sort-param*, sort@ConstType(SortNoArgs(_)))) ->
    $[rules
      
        [<gen-generic> sort-name]
    
        [<gen-sort(|cons-name)> sort-name]
      
        [<gen-constructor(|cons-name, cons, sort-param*)> sort-name]
    
    ]
    with
      sort-name   := <sort-name> sort;
      cons-name   := <cons-name(|<length> sort-param*)> cons

rules // Generic
  
  gen-generic:
    sort-name -> 
    $[[<generic-collect-name>] = [<specific-collect-name> sort-name]]
  
  
  collect-parameters = !"(sibling-uris|lang, partition, unique*, uri*)"
  generic-collect-name = !$[generic-collect[<collect-parameters>]]
  specific-collect-name:
    postfix -> $[specific-collect-[postfix][<collect-parameters>]]
  
  siblings-parameters = !"(|lang, partition, unique*, uri*)"
  specific-siblings-list-name:
    sort-name -> $[specific-siblings-list-[sort-name][<siblings-parameters>]]
  specific-siblings-name:
    cons-name -> $[specific-siblings-[cons-name][<siblings-parameters>]]

rules // Sorts
  
  sort-name: ConstType(SortNoArgs(sort)) -> sort
  sort-name: ConstType(Sort("List", [SortNoArgs(sort)])) -> sort
  sort-name: ConstType(Sort("Option", [SortNoArgs(sort)])) -> sort
  
  gen-sort(|cons-name):
    sort-name -> 
    ${{<specific-collect-name> sort-name} = {<specific-collect-name> cons-name}
    
      {<gen-sort-siblings> sort-name}}
    
  gen-sort-siblings:
    sort-name -> 
    ${{<specific-siblings-list-name>} =
        []  
      + [ specific-collect-{sort-name}(?sibling-uri*|lang, partition, unique*, uri*)
        | specific-siblings-list-{sort-name}(|lang, partition, unique*, sibling-uri*) ]
    }
    
rules // Constructors
  
  cons-name(|arity): cons -> $[[cons]-[arity]]
  
  gen-constructor(|cons-name, cons, sort-param*):
    sort-name ->
    ${specific-collect-{cons-name}(sibling-uris|lang, partition, unique*, uri*) = 
        nabl-state-pop(?state*)
      ; try({cons-name}-scoping-site)
      ; (
           nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
        <+ nabl-new-scope-site(?uri'*|lang, partition, unique*, uri*)
        <+ match(?uri'*|uri*) 
      ) 
      ; (
          {cons-name}-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
        ; try({cons-name}-new-scoping-site)
          <+ match(sibling-uris|uri*)
        ; match(?child-uri*|uri'*)
      )    
      ; try({cons-name}-state-site)
      ; try({cons-name}-collect-rewrite(|lang, partition, uri*, uri'*))
      {specific-siblings-call}
      ; try({cons-name}-external-def-site(|lang, partition, unique*, uri'*, state*, implicit*))
      ; try({cons-name}-use-site(|lang, partition, unique*, uri'*, state*))
      ; try({cons-name}-import-site(|lang, partition, unique*, child-uri*, state*))
      ; try({cons-name}-filtering-site(|lang, partition, unique*, uri*, state*))
      ; try({cons-name}-disambiguation-site(|lang, partition, unique*, uri*, state*))
      ; try({cons-name}-prop-site(|lang, partition, uri*, state*, implicit*))
      ; nabl-annotate-properties(|lang, partition, uri*, uri'*)
        
      {specific-siblings-def}
        
      {cons-name}-collect-rewrite(|lang, partition, old-uri*, new-uri*) = fail
      {cons-name}-scoping-site = fail
      {cons-name}-new-scoping-site = fail
      {cons-name}-def-site(child-uris, sibiling-uris, implicits| lang, partition, unique*, uri*, state*) = fail
      {cons-name}-external-def-site(|lang, partition, unique*, uri*, state*, implicit*) = fail
      {cons-name}-state-site = fail
      {cons-name}-use-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-filtering-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-disambiguation-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-import-site(|lang, partition, unique*, uri*, state*) = fail
      {cons-name}-prop-site(|lang, partition, uri*, state*, implicit*) = fail}
    with
      if <gt> (<length> sort-param*, 0) then
        specific-siblings-call := ${; specific-siblings-{cons-name}(|lang, partition, unique*, uri*)};
        congruence-part-str := <gen-specific-siblings-congruence(|0); separate-by(|", "); concat-strings> sort-param*;
        specific-siblings-def  :=
          ${{<specific-siblings-name> cons-name} =
              preserve-annos(origin-track-forced(
                {cons}(
                  {congruence-part-str}  
                )
              ))
            
          }
      else
        specific-siblings-call := "";
        specific-siblings-def  := ""
      end
  
  gen-specific-siblings-congruence(|n):
    [sort, next-sort | sortz] -> [part-str | <gen-specific-siblings-congruence(|n')> [next-sort | sortz]]
    with
      (part-str, n') := <gen-specific-siblings-part(|n)> sort

  gen-specific-siblings-congruence(|n):
    [sort] -> [part-str]
    with
      (part-str, _) := <gen-specific-siblings-part(|n)> sort

  gen-specific-siblings-part(|n):
    _ -> ($[specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, uri*)], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    + ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      0 := n
      
  gen-specific-siblings-part(|n):
    _ -> ($[specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, sibling-uri-[<dec> n]*)], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    + ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      not(0 := n)
    
  gen-specific-siblings-part(|n):
    ConstType(Sort("List", [SortNoArgs(sort-name)])) -> 
    ($[specific-siblings-list-[sort-name](|lang, partition, unique*, uri*)], n)
