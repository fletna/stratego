module spectrav

imports
  
  include/Stratego-Sugar
  lib/runtime/nabl/utils
  
rules // Builder
  
  generate-specific-traversal:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"traversal.str")> path;
      result   := <gen-spectrav-module> ast
  
rules // Top rule
  
  gen-spectrav-module:
    Module(m, decl*) -> 
    ${module {m}.traversal
      
      imports
        
        {m}
        lib/nabl/-
        lib/properties/-
        lib/editor/-
      
      rules // Built-ins
        
        spectrav-match-defaults(sibling-uris, implicits-up, uris-up, child-uris-up, state-up|uri*) =
          match(sibling-uris|uri*)
        ; match(implicits-up|[])
        ; match(uris-up|uri*)
        ; match(child-uris-up|uri*)
        ; match(state-up|[])
                
        {<gen-generic> "Int"}
        {<specific-collect-name> "Int"} = where(is-int); match(sibling-uris|uri*)
        {<gen-generic> "String"}
        {<specific-collect-name> "String"} = where(is-string); match(sibling-uris|uri*)
      
      rules // Sibling list traversals
      	
      	{sib-list-trav}
      
      {traversal}}
    with
      sig*          := <collect-all(?Constructors(<id>)); concat> decl*;
      sib-list-trav := <filter(sig-sort-name); make-set; map(gen-sort-siblings); concat-strings> sig*;
      traversal     := <filter(gen-spectrav); concat-strings> sig*

rules // Sort names from signatures
	
	sig-sort-name: OpDeclInj(FunType(_, ConstType(SortNoArgs(sort-name)))) -> sort-name
	sig-sort-name: OpDecl(_, ConstType(SortNoArgs(sort-name)))             -> sort-name
	sig-sort-name: OpDecl(_, FunType(_, ConstType(SortNoArgs(sort-name)))) -> sort-name
		 
rules // Specific traversal generation
      
  gen-spectrav:
    OpDeclInj(FunType([inj-sort], sort@ConstType(SortNoArgs(_)))) -> 
    $[rules // Sort [sort-name], injected into [inj-sort-name]
        [<gen-generic> sort-name]
        [<specific-collect-name> sort-name] = [<specific-collect-name> inj-sort-name]
    
    ]
    with
      sort-name     := <sort-name> sort;
      inj-sort-name := <sort-name> inj-sort

      
  gen-spectrav:
    OpDecl(cons, sort@ConstType(SortNoArgs(_))) -> 
    $[rules // Constructor [cons-name], Sort [sort-name]
        [<gen-generic> sort-name]
        [<gen-sort(|cons-name)> sort-name]
        [<gen-constructor(|cons, 0, [])> sort-name]
      
    ]
    with
      sort-name   := <sort-name> sort;
      cons-name   := <cons-name(|0)> cons
    
  gen-spectrav:
    OpDecl(cons, FunType(sort-param*, sort@ConstType(SortNoArgs(_)))) ->
    $[rules // Constructor [cons-name], Sort [sort-name]
        [<gen-generic> sort-name]
        [<gen-sort(|cons-name)> sort-name]
        [<gen-constructor(|cons, cons-arity, sort-param*)> sort-name]
    
    ]
    with
      sort-name   := <sort-name> sort;
      cons-arity  := <length> sort-param*;
      cons-name   := <cons-name(|cons-arity)> cons

rules // Rules for the generic traversal
  
  gen-generic:
    sort-name -> 
    $[[<generic-collect-name>] = [<specific-collect-name> sort-name]]

rules // Rules for sort-specific traversal
  
  sort-name: ConstType(SortNoArgs(sort)) -> sort
  sort-name: ConstType(Sort("List", [SortNoArgs(sort)])) -> sort
  sort-name: ConstType(Sort("Option", [SortNoArgs(sort)])) -> sort
  
  gen-sort(|cons-name):
    sort-name -> 
    ${{<specific-collect-name> sort-name} = {<specific-collect-name> cons-name}}
    
  gen-sort-siblings:
    sort-name -> 
    ${{<specific-siblings-list-name>} =
        []
      + [ specific-collect-{sort-name}(?sibling-uri*|lang, partition, unique*, uri*)
        | specific-siblings-list-{sort-name}(|lang, partition, unique*, sibling-uri*) ]
      specific-siblings-option-{sort-name}(sibling-uris|lang, partition, unique*, uri*) =
        (None(); match(sibling-uris|uri*))
      + Some(specific-collect-{sort-name}(sibling-uris|lang, partition, unique*, uri*))
      + specific-collect-{sort-name}(sibling-uris|lang, partition, unique*, uri*)
      
    }
    
rules // Rules for constructor-specific traversal
  
  cons-name(|arity): cons -> $[[cons]-[arity]]
  
  gen-constructor(|cons, arity, sort-param*):
    sort-name ->
    ${specific-collect-{cons-name}(sibling-uris|lang, partition, unique*, uri*) =
        {cons-match} 
      ; ({cons-name}-down(sibling-uris, ?implicit*, ?uri'*, ?child-uri*, ?state*|lang, partition, unique*, uri*) <+ spectrav-match-defaults(sibling-uris, ?implicit*, ?uri'*, ?child-uri*, ?state*|uri*))
      {specific-siblings}
      ; try({cons-name}-up(|lang, partition, unique*, implicit*, uri*, uri'*, child-uri*, state*))
      ; <foldl({cons-name}-annotate-property(|lang, partition, uri*, uri'*) <+ Snd)> (<nabl-get-all-properties>, <id>)
      ; try({cons-name}-constraint(|partition, uri*, uri'*))
        
      {cons-name}-down(sibling-uris, implicits-up, uris-up, child-uris-up, states-up|lang, partition, unique*, uri*) = fail
      {cons-name}-up(|lang, partition, unique*, implicit*, uri*, uri'*, child-uri*, state*) = fail
      
      {cons-name}-annotate-property(|lang, partition, old-uri*, new-uri*):
        (kind, term{"{"}a*{"}"}) -> term{"{"}(kind, prop), a*{"}"}
        where
          not(<get-property-task(|kind)> term)
        ; prop := <{cons-name}-property-task(|partition, kind, old-uri*, new-uri*)> term
      {cons-name}-property-task(|partition, kind, old-uri*, new-uri*) = fail
      {cons-name}-constraint(|partition, old-uri*, new-uri*) = fail
}
    with
    	cons-name  := <cons-name(|arity)> cons;
    	cons-match := <gen-constructor-match(|arity)> cons;
      if <gt> (<length> sort-param*, 0) then
        congruence-part-str := <gen-specific-siblings-congruence; separate-by(|", \n"); concat-strings> sort-param*;
        specific-siblings   :=
          $[; [<gen-debug-before(|"b")>]preserve-annotations-attachments([cons](
                [congruence-part-str]
              ))[<gen-debug-after(|"a")>]]
      else
        specific-siblings := ""
      end
  
  gen-constructor-match(|arity):
  	name -> $[?[name]([<repeat(!["_"|<id>]|arity); separate-by(!", ")> []])]
  
  gen-specific-siblings-congruence = gen-specific-siblings-congruence(|0, 0)
  
  gen-specific-siblings-congruence(|n, d):
    [sort, next-sort | sortz] -> [part-str | <gen-specific-siblings-congruence(|n', <inc> d)> [next-sort | sortz]]
    with
      (part-str, n') := <gen-specific-siblings-part(|n, d)> sort

  gen-specific-siblings-congruence(|n, d):
    [sort] -> [part-str]
    with
      (part-str, _) := <gen-specific-siblings-part(|n, d)> sort

  gen-specific-siblings-part(|n, d):
    _ -> ($[[<gen-debug-before(|$[ [d]-b])>]specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, child-uri*)[<gen-debug-after(|$[ [d]-a])>]], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    where
      0 := n
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[[<gen-debug-before(|$[ [d]-b])>]specific-collect-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, sibling-uri-[<dec> n]*)[<gen-debug-after(|$[ [d]-a])>]], <inc> n)
    where
      ?ConstType(SortNoArgs(sort-name))
    where
      not(0 := n)
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[[<gen-debug-before(|$[ [d]-b])>]specific-siblings-option-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, uri*)[<gen-debug-after(|$[ [d]-a])>]], <inc> n)
    where
      ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      0 := n
      
  gen-specific-siblings-part(|n, d):
    _ -> ($[[<gen-debug-before(|$[ [d]-b])>]specific-siblings-option-[sort-name](?sibling-uri-[n]*|lang, partition, unique*, sibling-uri-[<dec> n]*)[<gen-debug-after(|$[ [d]-a])>]], <inc> n)
    where
      ?ConstType(Sort("Option", [SortNoArgs(sort-name)]))
    where
      not(0 := n)
    
  gen-specific-siblings-part(|n, d):
    ConstType(Sort("List", [SortNoArgs(sort-name)])) -> 
    ($[[<gen-debug-before(|$[ [d]-b])>]specific-siblings-list-[sort-name](|lang, partition, unique*, child-uri*)[<gen-debug-after(|$[ [d]-a])>]], n)

rules // Naming of generated rules
	
	collect-parameters = !"(sibling-uris|lang, partition, unique*, uri*)"
  generic-collect-name = !$[generic-collect[<collect-parameters>]]
  specific-collect-name:
    postfix -> $[specific-collect-[postfix][<collect-parameters>]]
  
  siblings-parameters = !"(|lang, partition, unique*, uri*)"
  specific-siblings-list-name:
    sort-name -> $[specific-siblings-list-[sort-name][<siblings-parameters>]]
    
rules // Debugging
	
	gen-debug(|msg) = (spectrav-should-debug; gen-debug-msg(|$[[msg][" "]])) <+ !""
	gen-debug-before(|msg) = (spectrav-should-debug; !$[[<gen-debug-msg(|$[[msg][" "]])>];[" "]]) <+ !""
	gen-debug-after(|msg) = (spectrav-should-debug; !$[; [<gen-debug-msg(|$[[msg][" "]])>]]) <+ !""
	gen-debug-msg(|msg) = !$[debug(|"[msg]")]
	spectrav-should-debug = fail
