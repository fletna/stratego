module refactoring/inline

imports
  libstrc

rules //inline refactoring

inline-refactoring:
  (_, selected, position, ast, path, project-path) -> 
  (ast-changes, fatal-errors, [], warnings)
    where
      declaration := <?(<?SDefT(_, _, _, _)>, _) <+ declaration-of-call> (selected, ast);
      warnings := <warnings-multiple-declarations> (declaration, ast);
      fatal-errors := <errors-recursion> declaration;
      if <?[]> fatal-errors then
        ast-changes := [(ast, <inline> (declaration, ast))]
      else
        ast-changes := []
    end
    
declaration-of-call:
  (CallT(SVar(name{ref}), _, _), ast) -> declaration
  where
    <oncetd(declaration := <?SDefT(name{ref}, _, _, _)>)> ast

errors-recursion:
  decl@SDefT(name{ref}, _, _, _) -> errors
  where
    if <is-recursive-declaration> decl then
      errors := [(decl, "strategy declaration contains recursive call")]
    else
      errors := []
    end

is-recursive-declaration:
  decl@SDefT(name{ref}, _, _, _) -> decl
  where
    <oncetd(?Rec(_, _) <+ ?SVar(name{ref}))> decl

warnings-multiple-declarations:
  (SDefT(name{ref}, _, _, _), ast) -> warnings
  where
    all-defs := <collect-all(?SDefT(name{ref}, _, _, _))> ast;
    if <?[_,_|_]> all-defs then
      warnings := <map(!(<id>, "multiple declarations found"))> all-defs
    else
      warnings := []
    end
    
inline:
  (decl@SDefT(name{ref}, _, _, _), ast) -> ast-inlined
  where
    ast-inlined := <
      topdown(try(inline-call(|decl)));
      delete-elements(?decl)
    > ast 
  
inline-call(|decl):
  CallT(SVar(name{ref}), svalues, tvalues) -> inlined-body
  where
    <?SDefT(name{ref}, svars, tvars, body)> decl;
    s-uses := <map(svardec-to-svaruse)> svars;
    t-uses := <map(tvardec-to-tvaruse)> tvars;
    inlined-body := <
      substitute-multiple(|s-uses, svalues);
      substitute-multiple(|t-uses, tvalues);
      try(rule-to-lambda-rule);
      scope-free-vars
    > body

scope-free-vars =
  try(!Scope(<collect-vars; not(?[])>, <id>))
  //TODO: warning, programmar may not be happy with the result?
  
collect-vars =
	topdown(strip-annos);
	collect-om(
		?Var(<id>) <+ collect-vars-scope 
	);
	flatten-list; make-set

collect-vars-scope:
	Scope(scoped-vars, body) -> <diff>(<collect-vars> body, scoped-vars)

rule-to-lambda-rule:
  rule@Rule(_, _, _) -> LRule(rule)

svardec-to-svaruse:
  VarDec(name{ref}, _) -> CallT(SVar(name{ref}), [], [])

tvardec-to-tvaruse:
  VarDec(name{ref}, _) -> Var(name{ref})

substitute-multiple(|vars, values):
  body -> new-body
  where
    <?[hvar|tl-vars]> vars;
    <?[hvalue|tl-values]> values;
    new-body := <
      substitute-single(|hvar, hvalue);
      substitute-multiple(|tl-vars, tl-values)
    > body

substitute-multiple(|vars, values):
  body -> body
  where
    <?[]> vars;
    <?[]> values

substitute-single(|var, value):
  body -> new-body
  where
    new-body := <topdown(try(?var; !value))> body

delete-elements(is-deletion-elem):
  ast -> ast-t
  where
    ast-t := <topdown(try(filter(not(is-deletion-elem))))> ast
