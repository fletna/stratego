module signatures/map

imports
	signatures/constructors
	signatures/project
	libstrc
	utils/utils
	
rules // store & retrieve sorts
			
		store-sort-decl:
			sig -> cookie
			where
				signature-sort;
				not(is-prim)
			with
				signature-sort => sort;
				get-sort-cookie => cookie;
				not(
					<elem> (sig,<bagof-DeclaredSort> cookie)
				) <
					rules (
						DeclaredSort:+ cookie -> sig
					)
					+
					id
		
		get-sort-decls:
			sort -> decls
			where
				?_{cookie};
				decls := <bagof-DeclaredSort> cookie

		// already has a cookie
		get-sort-cookie:
			sort -> cookie
			where
				?_{cookie} +
				?s#(l@_);
				all-keys-SortCookie;
				filter(\
				s'#(l'@_) -> <and(<eq> (s',s), <eq> (<length> l',<length> l))>
				\);
				mapconcat(bagof-SortCookie);
				?[cookie|_]

		// no cookie yet		
		get-sort-cookie:
			sort -> cookie
			where not(is-prim)
			where not(
				?_{_} +
				?s#(l@_);
				all-keys-SortCookie;
				filter(\
				s'#(l'@_) -> <and(<eq> (s',s), <eq> (<length> l',<length> l))>
				\);
				?[_|_]
			)
			with
				cookie := <newterm>;
				rules (
					SortCookie:+ sort -> cookie
				)
				
rules // transparent auto-declarations for the primitive sorts
	/* when a primitive sort is used we automatically declare it */
	// get-sort-decl: List(_) -> <declare-me;get-declaration>
	
	/* there are two types:
		1. sort usage:
			- is cookie-stored during signature-of (probably not the best time)
		2. sort declaration:
			- is stored after signature-of from declare-globals

		For non-primitives:
			1. stores (if not already stored) a cookie for that Sort and returns it [get-sort-cookie]
			2. if it is not already declared stores the constructor declaration as a sort declaration
				and returns the cookie [store-sort-decl]
			
		For primitives:
			1. allocate a cookie (if not already allocated) for that primitive and return it. also store the built-in declaration
				for that sort so that we have it for later [get-sort-cookie].
			2. basically a dummy. all primitives should have been declared already (including parameterized ones hopefully). Just
				returns the cookie
					
	*/
		
		store-sort-decl:
			sig -> cookie
			where
				signature-sort;
				is-prim;
				get-sort-cookie => cookie
		
		//normal sort
		get-sort-cookie:
			sort -> cookie
			where
				is-prim;
				?srt#([])
			where not(
				?_{_} + SortCookie
			)
			with
				cookie := <newterm>;
				sig := ConstSig(srt,[],srt#([]){cookie},[]);
				rules (
					SortCookie:+ sort -> cookie
					DeclaredSort:+ cookie -> sig
				)
		
		//parameterized sort
		get-sort-cookie:
			sort -> cookie
			where
				is-prim;
				?srt#([_|_])
			where not(
				?_{_} + SortCookie
			)
			with
				cookie := <newterm>;
				sig := ConstSig(srt,[Var("a")],srt#([Var("a")]),["a"]);
				rules (
					SortCookie:+ sort -> cookie
					DeclaredSort:+ cookie -> sig
				)

rules // rename variables
	
	rename-sort-vars = {| RenamedVar: alltd(rename-sort-var) |}
	
	rename-sort-var:
		SortVar(v) -> SortVar(v){<rename> v}
		where debug(!$[Renamed variable [v] to [<rename> v] ])
		
	rename:
		v -> v'
		where
			is-string;
			RenamedVar => v'
	
	rename:
		v -> v'
		where
			is-string;
			not(RenamedVar)
		with
			v' := <newterm>;
			rules (
				RenamedVar : v -> v'
				RenamedVarCookie: v' -> v
			)
	

rules // variable sort storage
	
	chain-proxy-varsort(|var,pos):
		sig@(_#(use-args)) -> var
		with
			if(not(<VarToProxy> var => old_cookie)) then
				old_cookie := -42
			end;
			cookie := <newterm>;
			// verify that a var actually exists at the given position
			var-positions := <get-indices(?Var(var))> use-args;
			<elem> (pos,var-positions);
			num_args := <length> use-args
		with
			if(<gt> (old_cookie,0)) then
				// a rule already exists, cleanup
				rules (
					VarToProxy:- var
					SortVar:- var
				)
			end;
			rules (
				VarToProxy: var -> cookie
				DeferredApplication: cookie -> result
					with
						<get-sort-decls> sig;
						// keep from the decls only those that have the right number of arguments
						map(signature-sort);
						filter(\
							_#(decl-args) -> decl-args
							where <eq> (<length> decl-args, num_args)
							\);
						// FIXME: keep from the remaining decls only those that apply in non-variable positions
						// FIXME: this is loss of strictness
						// keep only the positions at POS
						map(elem-at-index(|pos)) => elems;
						if(<gt> (old_cookie,0)) then
							<sort-apply <+ ![]> (<DeferredApplication> old_cookie, elems) => result
						else
							<sort-apply <+ ![]> (Term(), elems) => result
						end
				SortVar: var -> <DeferredApplication> cookie
			)
	
	
	chain-proxy-varsort(|var):
		sig@(_#(use-args)) -> var
		with
			var-positions := <get-indices(?Var(var))> use-args;
			<map(\ 
				pos -> <chain-proxy-varsort(|var,pos)> sig
			\)> var-positions
			
	get-var-sorts:
		var -> srts
		where all-keys-SortVar;fetch(?var)
		with {|Strace:
			if(<Strace> var) then
				<debug(!"Cyclic lookup detected on ")> Var(<RenamedVarCookie> var);
				srts := [Term()]
			else
				rules (
					Strace: var
				);
				<SortVar> var => srts
			end
		|}
	
	get-var-sorts:
		var -> [Term()]
		where all-keys-SortVar;not(fetch(?var))
	
	store-var-sorts(|var):
		srts -> srts
		where <is-list> srts
		with rules (
			SortVar: var -> srts
		)