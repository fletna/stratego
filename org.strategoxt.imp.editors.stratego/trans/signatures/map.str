module signatures/map

imports
	signatures/constructors
	signatures/project
	utils/utils
	libstrc

rules // map signatures to their internal declarations
	
	poly-sort-signature-of =
			sort-signature-of;
			to-poly-signature

	// normal signature with name and function	
	sort-signature-of: 
		OpDecl(name, FunType(args,srt)){decl-id} -> ConstSig(name,args',srt',[],decl-id)
		with
			args' := <map(sort-signature-of)> args;
			srt' := <sort-signature-of> srt
	
	// signature with no arguments	
	sort-signature-of:
		OpDecl(name, ConstType(srt)){decl-id} -> ConstSig(name,[],srt',[],decl-id)
		with
			srt' := <sort-signature-of> srt			
			
	// signature with no name
	sort-signature-of:
		OpDeclInj(FunType(args,srt)){decl-id} -> ConstSig("",args',srt',[],decl-id)
		with
			args' := <map(sort-signature-of)> args;
			srt' := <sort-signature-of> srt
	
	sort-signature-of:
		OpDeclInj(ConstType(srt)){decl-id}-> ConstSig("",[],srt',[],decl-id)
		with
			srt' := <sort-signature-of> srt
	
	sort-signature-of:
		ConstType(s) -> <sort-signature-of> s
	
	sort-signature-of:
		SortVar(v){vnum} -> Var(vnum)
	
	sort-signature-of:
		SortNoArgs(s) -> sort
		with
			srt := s#([]);
			sort := srt{<get-sort-cookie> srt}
	
	sort-signature-of:
		Sort(s,a) -> sort
		with
			srt := s#(<sort-signature-of> a);
			sort := srt{<get-sort-cookie> srt}
		
	sort-signature-of:
		SortTuple(sort-list) -> sort
		with
			srt := <map(sort-signature-of);new-tuple-sort> sort-list;
			sort := srt{<get-sort-cookie> srt}
		
	sort-signature-of:
		t -> <map(sort-signature-of)> t
		where ?[_|_] //is-list
	
	sort-signature-of:
		[] -> []
	
	// get all the variables from the LHS of constructor
	to-poly-signature:
		ConstSig(n,args,srt,_,decl-id) -> ConstSig(n,args,srt,<new-configuration> freevars,decl-id)
		with
			freevars := <collect-all(\ Var(a) -> a \,union)> args
	
rules // store & retrieve sorts
		
		store-sort-decl:
			sig@ConstSig(_,_,_,_,decl-id) -> cookie
			where
				signature-sort => sort;
				not(is-sort-prim)
			with
				cookie := <get-sort-cookie> sort;
				// (<elem> (sig,<bagof-DeclaredSort;mapconcat(SortSig)> cookie)
				(<get-sort-declaration> decl-id
				<+
				rules (
					DeclaredSort:+ cookie -> decl-id
					SortSig: decl-id -> sig
				))
		
		replace-sort-decl:
			sig@ConstSig(_,_,_,_,decl-id) -> sig
			where
				<get-sort-declaration> decl-id
			with rules (
				SortSig: decl-id -> sig
			)
		
		
		get-sort-declarations:
			// _{cookie} -> <bagof-DeclaredSort;mapconcat(bagof-SortSig)> cookie
			_{cookie} -> <bagof-DeclaredSort;map(get-sort-declaration)> cookie
			
		get-sort-declarations:
			s{} -> <get-sort-cookie => cookie;!s{cookie};get-sort-declarations> s
		
		get-sort-declaration:
			decl-id -> <SortSig> decl-id 
			// decl-id -> <all-keys-DeclaredSort;mapconcat(bagof-DeclaredSort);fetch-elem(?ConstSig(_, _, _, _, decl-id))>
		
		get-signatures-for-constructor:
			c -> <all-keys-SortSig;mapconcat(bagof-SortSig);filter(?ConstSig(c, _, _, _, _))>
		/* 
		* get cookie for non-primitive sort (parameterized or not)
		*/
		
		get-sort-cookie:
			sort{cookie} -> cookie
			// where debug(!"Getting sort cookie for declared sort which has a cookie-anno ")
		
		get-sort-cookie:
			sort -> cookie
			where not(?_{_})
			where
				?s#(_);
				!s#([]);
				SortCookie => cookie
				// ;<debug(!"Getting cookie for declared sort which doesn't have an cookie-anno ")> sort

		// no cookie yet
		/* we are ignoring any parameters that the sort has */		
		get-sort-cookie:
			sort -> cookie
			where not(is-sort-prim)
			where not(?_{_})
			where 
				?s#(_);
				!s#([]) => srt
			where not(
				!srt;
				SortCookie
			)
			// where debug(!"Storing cookie for non-primitive sort ")
			with
				cookie := <newterm>;
				// store the cookie as unparameterised sort
				rules (
					SortCookie: srt -> cookie
				)
				
rules // transparent auto-declarations for the primitive sorts
	/* when a primitive sort is used we automatically declare it */
	// get-sort-decl: List(_) -> <declare-me;get-declaration>
	
	/* there are two types:
		1. sort usage:
			- is cookie-stored during signature-of (probably not the best time)
		2. sort declaration:
			- is stored after signature-of from declare-globals

		For non-primitives:
			1. stores (if not already stored) a cookie for that Sort and returns it [get-sort-cookie]
			2. if it is not already declared stores the constructor declaration as a sort declaration
				and returns the cookie [store-sort-decl]
			
		For primitives:
			1. allocate a cookie (if not already allocated) for that primitive and return it. also store the built-in declaration
				for that sort so that we have it for later [get-sort-cookie].
			2. basically a dummy. all primitives should have been declared already (including parameterized ones hopefully). Just
				returns the cookie
					
	*/
		
		store-sort-decl:
			sig -> cookie
			where
				signature-sort;
				is-sort-prim;
				// debug(!"Storing declaration for primitive sort ");
				get-sort-cookie => cookie
				
		
		/* primitive sort (whether parameterized or not)
		* If its parameterized it gets automatically declared with variables in the different parameter positions.
		* Tuple is a special case:
		* - Tuple-2(_,_) -> ConstSig("",[Var(a),Var(b)],Tuple-2(Var(a),Var(b)){cookie},[Var(a),Var(b)])
		* - Tuple-3(_,_,_) -> ConstSig("",[Var(a),Var(b),Var(c)],Tuple-2(Var(a),Var(b),Var(c)){cookie},[Var(a),Var(b),Var(c)])
		*/
		get-sort-cookie:
			sort -> cookie
			where
				is-sort-prim
			where not(
				?_{_} + SortCookie
			)
			// where debug(!"Storing cookie for primitive sort ")
			with
				cookie := <newterm>;
				// gen the list of arguments (variables)
				var-args := <list-of(new-var|[],<arity> sort)>;
				// sig := ConstSig("",var-args,sort{cookie},var-args);
				decl-id := <newterm>;
				sig := ConstSig("",var-args, <?s#(_);!s#(var-args){cookie}> sort,<new-configuration> var-args, decl-id);
				srt := s#([]);
				rules (
					SortCookie: srt -> cookie
					DeclaredSort:+ cookie -> decl-id
					SortSig: decl-id -> sig
				)
		
		// TODO: move these two to a utilities module
		
		// generate a list of the given element
		list-of(|acc,length):
			k -> <list-of(!k|acc,length)>

		// generates a list of the given element producing strategy
		list-of(s|accumulator,length) =
			if(<gt> (length,0)) then
				list-of(s|[<s>|accumulator],<dec> length)
			else
				!accumulator
			end
		
rules // rename variables
	
	rename-sort-vars = {| RenamedVar: alltd(rename-sort-var) |}
	
	rename-sort-var:
		SortVar(v) -> SortVar(v){<rename> v}
		// where debug(!$[Renamed variable [v] to [<rename> v] ])
		
	rename:
		v -> v'
		where
			is-string;
			RenamedVar => v'
	
	rename:
		v -> v'
		where
			is-string;
			not(RenamedVar)
		with
			// v' := <newterm>;
			v' := <newname> v;
			rules (
				RenamedVar : v -> v'
				RenamedVarCookie: v' -> v
			)
		
		new-var = !Var(<newname> "var")

	
