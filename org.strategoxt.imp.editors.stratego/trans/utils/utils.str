module utils

imports lib/editor-common.generated

rules /* list utilities */
	
	
	can-be-unique-value-term =
		not(is-string + is-tuple + is-list + is-real);?c#(_);<?"">c
	
	/**
	* returns a list containing the indices at which the given strategy succeeds
	* List(a) -> List(Int)
	*/
	get-indices(s) = get-indices(s|0)
	// 
	get-indices(s|index):
		[x|xs] -> [index|<get-indices(s|<inc> index)> xs]
		where <s> x
	// 
	get-indices(s|index):
		[x|xs] -> <get-indices(s|<inc> index)> xs
		where <not(s)> x
	// 
	get-indices(s|index): [] -> []
	
 	/**
 	* returns a sublist consisting of the elements at the given indices
 	* List(a) -> List(a)
 	*/
	at-indices(|indices) = at-indices(|indices,0)
	
	at-indices(|indices,curindex):
		[x|xs] -> [x|<at-indices(|indices,<inc> curindex)> xs]
		where <elem> (curindex,indices)
	
	at-indices(|indices,curindex):
		[x|xs] -> <at-indices(|indices,<inc> curindex)> xs
		where <not(elem)> (curindex,indices)
	
	at-indices(|indices,curindex):
		[] -> []
 	
 	// FIXME: this is not necessary. we can refactor to use the built in one.
 	elem-at-index(|index) = index(|<inc> index)

	/**
	* Wrapper for foldl to take the starting value as a strategy argument
	* @param s1: _ -> b
	* @param s2: (b,a) -> b
	* @type: List(a) -> b
	*/
	foldll(s1,s2):
		t -> <foldl(s2)> (t,<s1>) 
	
	/**
	* Wrapper for fold-left to simulate left reduce. Fails if the list is empty.
	*/
	reducel(s):
		[e1|xs] -> <foldl(\(a,b) -> (b,a)\;s)> (xs,e1)
	
	head = ?[x];!x
	
	/**
	* A wrapper around cartesion product to process a list of lists.
	*/		
	// long-cart(s: (a,a) -> a):
	long-cart(s):
		[l1,l2] -> <cart(s)> (l1,l2)
	
	// long-cart(s: (a,a) -> a):
	long-cart(s):
		[l1,l2|xs@[_|_]] -> out
		where
			interim := <cart(s)> (l1,l2);
			out := <long-cart(s)> [interim|xs]
	
rules /* tree utilities */
	
	// FIXME: this is not necessary. we can use subterm-at(|index) from editor-common
	argument-at-position(|pos):
		// _#(args) -> <take(|<inc> pos);last> args
		_#(args) -> <index(|pos)> args

	positions-of-term(s) = 
		// first annotate the terms with their path
		positions-of-term(s|[]);
		collect-all(where(s);\ _{path} -> path \,conc)
	
	positions-of-term(s|path):
		e@t#(t-args) -> result
		with
			t-args' := <add-indices;map(\ (i,e) -> <positions-of-term(s|<conc> (path,[<dec> i]))> e \)> t-args;
			if(<s> e) then
				result := t#(t-args'){path}
			else
				result := t#(t-args')
			end
	
	terms-at-positions(|positions) = ?tree; <map(\ pos -> <term-at-position(|pos)> tree \)> positions
	
	parent-at-position(s|position) = parent-at-position(|position);where(s)
	
	parent-at-position(s|position):
		p -> <parent-at-position(s|position')> p
		where
			<parent-at-position(|position)> p;
			not(s)
		where
			// previous position
			if(<not(?[])> position) then
				position' := <take(|<dec> <length> position)> position
			end
	
rules /* constructor utilities */
	arity:
		_#(a) -> <length> a
			
