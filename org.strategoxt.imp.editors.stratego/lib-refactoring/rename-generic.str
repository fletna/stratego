module lib-refactoring/rename-generic

imports
  lib-refactoring/user-interaction
  lib-refactoring/fetch 

rules //helper functions for refactoring input terms

	/**
	 * Annotates AST with reference names (analyse),
	 * and fetches the annotated selection in the result AST 
	 * @type (String, T) -> (String{T}, T)
	 * @param T -> T (or: List(T) -> T)
	 */
	get-analysed-terms(analyse):
		(selected, ast) -> (ref-name, ast')
		where
			ast' := <analyse <+ (![<id>]; analyse; Hd)> ast;
			ref-name := <fetch-annotated-term(|<fetch-down(is-string)> selected)> ast'
  
  /*
   * Opens an input dialog for specifying a new name
   * Checks if input name is a an identifier (matches ID pattern, excluding keywords)
   * @type _ -> String 
   * @param String name of the language (@See editor/myLanguage.main.esv)
   */ 
  dialog-newname(|language) =
    <newname-dialog> (language, "rename", "new name: ", "")
  
  //TODO: dialog-newname(s|language) applies s while user types new name 

  /**
   * Reports precondition issues
   * @param _ -> (List(ERROR), List(WARNING)) with ERROR, WARNING String or (T, String)
   */
  report-precondition-issues(check-preconditions) =
    if (errors, warnings) := <check-preconditions> then
      <report-errors-warnings> ("The following problems are found: ", errors, warnings)
    end
    
  
  		
rules //refactoring transformation and semantic checks

  /**
   * Handles rename refactoring workflow.
   * Input: asts annotated with unique names
   * REMARK: save all resources before collecting ASTs and applying the refactoring 
   * - Checks if selected term is indeed a reference or declaration name
   * - Checks if the semantic errors before and after the transformation are the same
   * - Checks if the name bindings are preserved
   * @type (List(T)) -> List((T, T'))
   * @param List(T) -> List(T) strategy that annotates all names with a unique reference name. 
   * @param List(T) -> List(ERROR), with ERROR either a string or a tuple (term, String)   
   * @param String selected identifier annotated with unique reference name 
   * @param String new name   
   */
  apply-rename-refactoring(re-analyse, collect-sem-errors|ref-name, new-name):
    analyzed-asts -> changed-asts
    where
      <report-invalid-selection> ref-name;
      renamed-asts := <apply-renaming(|ref-name, new-name)> analyzed-asts;
      <report-semantic-issues(re-analyse, collect-sem-errors|ref-name, new-name)> (analyzed-asts, renamed-asts);
      changed-asts := <get-changed-asts> (analyzed-asts, renamed-asts)
            
  report-invalid-selection = 
    if not(is-string; has-annos) then 
      message-invalid-selection
    end
    
  report-semantic-issues(analyse, collect-sem-errors|ref-name, new-name) =
    check-semantics(analyse, collect-sem-errors|ref-name, new-name);
    (
    	report-semantic-problems <+
    	(try(dr-scope-all-end); dr-scope-all-start; fail) //do not store analysis results in name tables after rollback
    	//TODO: better solution
    )
    
  check-semantics(analyse, collect-sem-errors|ref-name, new-name) :
    (analyzed-asts, asts-after) -> (var-capture-warnings, <make-set> introduced-errors, <make-set> solved-errors)
    where    	
      errors-before        := <get-sem-errors(collect-sem-errors)> analyzed-asts; //debug(!"errors before: ");
      analyzed-asts-after  := <analyse> asts-after; //debug(!"asts-after: ");
      errors-after         := <get-sem-errors(collect-sem-errors)> analyzed-asts-after; //debug(!"errors after: ");
      (introduced-errors, solved-errors) := <check-consistency-changes> (errors-before, errors-after); 
      var-capture-warnings := <check-var-captures(|ref-name, new-name)> (analyzed-asts, analyzed-asts-after)
    	   	
  get-changed-asts:
    (asts-before, asts-after) -> changed-asts
    where
      changed-asts := <zip; filter(not(equal))> (
      	<topdown(try(strip-annos))> asts-before, 
      	<topdown(try(strip-annos))> asts-after
      )
    	
rules // transformation: renaming
    
  apply-renaming (|ref-name, new-name) =
    topdown(try(?ref-name; !new-name)); 
    topdown(try(strip-annos))
    
    
rules // consistency preservation
  
  check-consistency-changes:
    (errors-before, errors-after) -> (introduced-errors, solved-errors)
    where 
      introduced-errors := <diff> (errors-after, errors-before); 
      solved-errors     := <diff> (errors-before, errors-after) 
  
  get-sem-errors(collect-sem-errors) =
  	(
  		collect-sem-errors <+ 
  		map(collect-sem-errors); 
  		flatten-list
  	); topdown(strip-annos)
  	  
rules // behaviour preservation: invariant check for variabele capture

  check-var-captures(|ref-name, new-name):
    (analyzed-asts, analyzed-asts-after) -> errors
    where
      old-name := <strip-annos> ref-name; 
      errors   := <
        get-var-captures(|old-name, new-name);
        map(!(<id>, <!$[Variabele captures detected for '[<strip-annos>]']>))
      > (analyzed-asts, analyzed-asts-after)
  
  get-var-captures(|old-name, new-name):
    (analyzed-asts, analyzed-asts-after) -> var-captures
    where 
      paired-asts     := <zip> (analyzed-asts, analyzed-asts-after); //external definitions of transformed asts should not be obtained from cache
      reference-pairs := <map(get-paired-references(|old-name, new-name)); flatten-list> paired-asts;
      var-captures    := <check-invariant; map(Fst)> reference-pairs
    
  //compares the references of analysed ast before- and after- rename transformation     
  get-paired-references(|old-name, new-name):
    (ast-before, ast-after) -> ref-pairs
    where
      invariant_before := <get-listed-refnames(|old-name, new-name)> ast-before; //debug(!"invariant before: ");
      invariant_after  := <get-listed-refnames(|old-name, new-name)> ast-after; //debug(!"invariant after: ");
      ref-pairs     := <zip> (invariant_before, invariant_after)
          
  get-listed-refnames(|old-name, new-name) =
    collect-om(
      where(
      	strip-annos;
      	(equal(|old-name) <+ equal(|new-name))
      ),
      conc
    )
    
  //The pattern of declarations and variabele accesses should be the same before and after
  check-invariant = 
    ?[(x,y)|tail];
    filter(not(?(x,y)));
    (errors, remaining) := <partition(?(_,y) <+ ?(x,_))>;
    <conc>(errors, <check-invariant <+ ?[]> remaining)