module static-semantics

signature
  sorts Section SigSection Module OpDecl Sort Rule Term Type Def RuleCond
        ConstType Strategy SVar
  constructors
    Module       : string * list(Section) -> Module
    Signature    : list(SigSection) -> Section
    Rules        : list(Def) -> Section
    Strategies   : list(Def) -> Section
    
    Sorts        : list(Sort) -> SigSection
    Constructors : list(OpDecl) -> SigSection
    OpDecl       : string * Type -> OpDecl
    
    FunType      : list(Type) * Type -> Type
    ConstType    : Sort -> Type
    
    SortNoArgs   : string -> Sort
    RDefNoArgs   : string * Rule -> Def
    SDefNoArgs   : string * Strategy -> Def
    SDefTypeCheck: string * string * list(Type) -> Def
    RDecl	     : string * TYPE * TYPE -> Def
    RDeclT		 : string * list(TYPE) * list(TYPE) * TYPE -> Def
    Rule         : Term * Term * list(RuleCond) -> Rule
    
    WhereClause  : Strategy -> RuleCond
    WithClause   : Strategy -> RuleCond
    
    BA           : Strategy * Term -> Strategy
    CallNoArgs   : SVar -> Strategy
    CastValStrat : Def
   
    SVar         : string -> SVar
    
    OfType       : Term * TYPE -> Term
    CastTerm     : Term * TYPE * TYPE -> Term
    NoAnnoList   : Term -> Term
    Var          : string -> Term
    Tuple		 : list(Term) -> Term
    Op           : string * list(Term) -> Term
    App			 : Strategy * Term -> Term
    Seq			 : Strategy * Strategy -> Strategy
    Assign       : Term * Term -> Strategy
    Match        : Term -> Strategy
    Id           : Term
    Wld          : Term
    
  sorts TYPE
  constructors
    SRT : string -> TYPE
    FUN : list(TYPE) * TYPE -> TYPE
    TUP : list(TYPE) -> TYPE
    DYN : TYPE
    CAST: TYPE * TYPE -> TYPE
  
  
  namespaces
    Sort : string
    Cons : string
    Var : string
    Rule : string
    
  relations
    typeOfSort     : occurrence -> TYPE
    typeOfCons     : occurrence -> TYPE
    typeOfVar      : occurrence -> TYPE
    typeOfTerm     : occurrence -> TYPE
    typeOfRule 	   : occurrence -> TYPE
    typeOfStrategy : occurrence -> TYPE
    
  name-resolution 
    labels P

rules 

  insertCasts : Module -> Module
  insertCasts(m) = m' :- moduleOkC(m) == m'.
  
  insertTypeChecks : Module -> Module
  insertTypeChecks(Module(x, sections)) = Module(x, sections') :- {typechecks}
    insertTypeCheckSections(sections) == typechecks,
    sections' == concatenate(sections, [typechecks]).
    
  consistent: TYPE * TYPE
  consistent(DYN(), T).
  consistent(T, DYN()).
  
  consistentL maps consistent(list(*), list(*))
  
  cast: Term * TYPE * TYPE -> Term
  cast(e, T, T) = e.
  cast(e, T1, T2) = OfType(e, T2) :- consistent(T1, T2).
    
rules moduleOk : Module 
 
  moduleOk(m) :- {m'} moduleOkC(m) == m'.

  moduleOkC : Module -> Module

  moduleOkC(Module(x, sections)) = Module(x, sections') :- {s}
    new s,
    sectionsOk(s, sections) == sections'.

  concatenate : list(Section) * list(Section) -> list(Section)
  concatenate([s], s2) = s3 :- s3 == [s|s2].
  concatenate([s|s1], s2) = s3 :- s3 == [s|concatenate(s1, s2)].
  

rules 

  sectionOk  : scope * Section -> Section
  sectionsOk maps sectionOk(*, list(*)) = list(*)
  

rules // signatures
  
  sectionOk(s, Signature(sigsections)) = Signature(sigsections') :-
    sigSectionsOk(s, sigsections) == sigsections'.
  
  sigSectionOk: scope * SigSection -> SigSection
  sigSectionsOk maps sigSectionOk(*, list(*)) = list(*)
  
  sigSectionOk(s, Sorts(srts)) = Sorts(srts) :- 
    sortsOk(s, srts).
  
  sortOk : scope * Sort 
  sortsOk maps sortOk(*, list(*)) 
  
  sortOk(s, SortNoArgs(srt)) :- {d}
    d == Sort{srt@srt},
    s -> d with typeOfSort SRT(srt).
  
  sigSectionOk(s, Constructors(cdecls)) = Constructors(cdecls) :- 
    consDeclsOk(s, cdecls).
    
  consDeclOk : scope * OpDecl
  consDeclsOk maps consDeclOk(*, list(*))
  
  consDeclOk(s, OpDecl(c, FunType(srts, srt))) :- {ts t}
    typeOfSorts(s, srts) == ts,
    typeOfSort(s, srt) == t,
    s -> Cons{c@c} with typeOfCons FUN(ts, t).
    
  consDeclOk(s, OpDecl(c, ConstType(srt))) :- {t}
  	typeOfSort(s, ConstType(srt)) == t,
  	s -> Cons{c@c} with typeOfCons FUN([], t).
  
  typeOfSort : scope * Type -> TYPE
  typeOfSorts maps typeOfSort(*, list(*)) = list(*)
  
  typeOfSort(s, ConstType(SortNoArgs(srt))) = t :- {p d}
    typeOfSort of Sort{srt@srt} in s |-> [(p, (d, t))].
  
rules // rules 

  sectionOk(s, Rules(rs)) = Rules(rs') :- 
    rulesOk(s, rs) == rs'.
  
  ruleOk : scope * Def -> Def
  rulesOk maps ruleOk(*, list(*)) = list(*)
  
  ruleOk(s, RDecl(f, t1, t2)) = RDecl(f, t1, t2) :-
  	s -> Rule{f@f} with typeOfRule FUN([t1], t2). 
   
  ruleOk(s, SDefNoArgs(f, rules)) = SDefNoArgs(f, rules).
  ruleOk(s, SDefTypeCheck(f, c, rules)) = SDefTypeCheck(f, c, rules).
  
  ruleOk(s, RDefNoArgs(f, r)) = RDefNoArgs(f, r)  :- {s_r t1 t2 ts sg def}
    typeOfRule of Rule{f@f} in s |-> sg,
    resolveRule(s, RDefNoArgs(f, r), sg) == def.    
 
  resolveRule: scope * Def * list((path * (occurrence * TYPE))) -> Def
  
  
  resolveRule(s, RDefNoArgs(f, Rule(trm1, trm2, cond)), []) = RDefNoArgs(f, Rule(trm1', trm2', cond')) :- {s_r t1 t2}
  	new s_r, s_r -P-> s, 
  	typeOfMatchTerm(s_r, trm1) == t1,
  	cast(trm1, t1, DYN()) == trm1',
  	//t1 == DYN(),
    typeOfBuildTerm(s_r, trm2) == (trm2', t2),
    checkConds(s_r, cond) == cond'.
    
  	// s -> Rule{f@f} with typeOfRule FUN([DYN()], DYN()).	
  
  resolveRule(s, RDefNoArgs(f, Rule(trm1, trm2, cond)), [(_, (_, FUN([t], t')))]) = def :- {s_r t1 t2 trm2' cond'}
  	new s_r, s_r -P-> s,
  	typeOfMatchTerm(s_r, trm1) == t,
    typeOfBuildTerm(s_r, trm2) == (trm2', t'),
    checkConds(s_r, cond) == cond',
  	def == RDefNoArgs(f, Rule(trm1, trm2', cond')).
  	  
  checkCond: scope * RuleCond -> RuleCond
  checkConds maps checkCond(*, list(*)) = list(*)
  
  insertCast : scope * RuleCond -> RuleCond
  insertCast(s, cond) = cond' :-
    WithClause(BA(CallNoArgs(SVar("is-string")), Var("x"))) == cond'.
  
  checkCond(s, WhereClause(str)) = WhereClause(str') :-
  	checkStrategy(s, str) == str'.
  	  	
  checkCond(s, WithClause(str)) = WithClause(str') :-
  	checkStrategy(s, str) == str'.
  
  checkStrategy: scope * Strategy -> Strategy
  	
  checkStrategy(s, Seq(str1,str2)) = Seq(str1, str2) :- {t1 t2 t3}
  	checkStrategy(s, str1) == t1,
  	checkStrategy(s, str2) == t2,
  	typeOfStrategy(s, Seq(str1, str2)) == t3.
  	  
  checkStrategy(s, Assign(Var(x), sth)) = Assign(Var(x), trm) :- {t}
  	typeOfBuildTerm(s, sth) == (trm, t),
  	s -> Var{x@x} with typeOfVar t.
  	//typeOfVar of Var{x@x} in s |-> [(p, (d, t))],
  
  typeOfStrategy: scope * Strategy -> TYPE
  
  typeOfStrategy(s, Seq(str1, str2)) = FUN([t11], t22) :- {t12 t21}
  	typeOfStrategy(s, str1) == FUN([t11], t12),
  	typeOfStrategy(s, str2) == FUN([t21], t22),
  	consistent(t12,t21).
  	
  typeOfStrategy(s, CallNoArgs(SVar(str))) = t :- {p d t'}
  	typeOfRule of Rule{str@str} in s |-> [(p, (d, t'))],
  	t == t'.
  
  typeOfTerm: scope * Term -> TYPE
  
  typeOfMatchTerm : scope * Term -> TYPE
  typeOfMatchTerms maps typeOfMatchTerm(*, list(*)) = list(*)
  
  assertTypeOfMatchTerm : scope * Term -> TYPE
  assertTypeOfMatchTerms maps assertTypeOfMatchTerm(*, list(*)) = list(*)
  
  assertTypeOfMatchTerm(s, Var(x)) = t :-
  	s -> Var{x@x} with typeOfVar t.
  	
  assertTypeOfMatchTerm(s, Tuple(trms)) = TUP(ts) :-
  	assertTypeOfMatchTerms(s, trms) == ts.
  	
  assertTypeOfMatchTerm(s, Op(c, trms)) = t :- {p d ts ts'}
  	typeOfCons of Cons{c@c} in s |-> [(p, (d, FUN(ts, t)))],
  	assertTypeOfMatchTerms(s, trms) == ts.
  
  typeOfMatchTerm(s, NoAnnoList(Var(x))) = DYN() :-
    s -> Var{x@x} with typeOfVar DYN().  
  
  typeOfMatchTerm(s, NoAnnoList(term)) = t :-
    typeOfMatchTerm(s, term) == t.
  
  typeOfMatchTerm(s, Var(x)) = t :-
   	s -> Var{x@x} with typeOfVar t.
   	  
  typeOfMatchTerm(s, Op(c, trms)) = t :- {p d ts ts'}
    typeOfCons of Cons{c@c} in s |-> [(p, (d, FUN(ts, t)))],
    //typeOfMatchTerms(s, trms) == ts', consistentL(ts, ts').
    assertTypeOfMatchTerms(s, trms) == ts.
   
  typeOfMatchTerm(s, Tuple(trms)) = TUP(ts) :- 
  	typeOfMatchTerms(s, trms) == ts.
  	
  // BUILD TERMS	
  typeOfBuildTerm : scope * Term -> (Term * TYPE)
  typeOfBuildTerms: scope * list(Term) -> (list(Term) * list(TYPE))
  
  typeOfBuildTerms(s, [term]) = ([trm], [ty]) :-
  	typeOfBuildTerm(s, term) == (trm, ty).
  	
  typeOfBuildTerms(s, [hd|terms]) = ([hd'|terms'], [t|types]) :-
    typeOfBuildTerm(s, hd) == (hd', t),
    typeOfBuildTerms(s, terms) == (terms', types).
  
  typeOfBuildTerm(s, NoAnnoList(term)) = (NoAnnoList(term'), t) :-
    typeOfBuildTerm(s, term) == (term', t).
  
  typeOfBuildTerm(s, Var(x)) = (Var(x), t) :- 
   	typeOfVar of Var{x@x} in s |-> [(_, (_, t))].
  
  typeOfBuildTerm(s, Tuple(terms)) = (Tuple(terms'), TUP(ts)) :- 
  	typeOfBuildTerms(s, terms) == (terms', ts).
    
  typeOfBuildTerm(s, App(CallNoArgs(SVar(str)), term)) = (App(CallNoArgs(SVar(str)), trm), t') :- {p d ty term' t}
  	// if type of rule is (DYN -> sth) then casting will be handled inside of rule
  	// if type of rule isnt (DYN -> sth) then casting is handled on application site
  	typeOfRule of Rule{str@str} in s |-> [(p, (d, FUN([t], t')))],
  	typeOfBuildTerm(s, term) == (term', ty),
	handleRuleApp(s, t, term', ty) == trm.
  
  handleRuleApp : scope * TYPE * Term * TYPE -> Term
  handleRuleApp(s, DYN(), term, termType) = Var("x").
  
  handleRuleApp(s, t, CastTerm(term, ty1, ty2), termType) = CastTerm(term, ty, ty2) :-
  	consistent(t, ty2).
  
  handleRuleApp(s, t, term, termType) = term' :-
  	cast(term, termType, t) == term'.
  	
  typeOfBuildTerm(s, App(Seq(str1, str2), term)) = (App(Seq(str1, str2), trm), t') :- {t term'}
  	typeOfStrategy(s, Seq(str1, str2)) == FUN([t], t'),
  	typeOfBuildTerm(s, term) == (term', t),
  	handleRuleApp(s, t, term', t) == trm.
  	
  typeOfBuildTerm(s, Op(c, trms)) = (Op(c, trms'), t) :- {p d ts}
    typeOfCons of Cons{c@c} in s |-> [(p, (d, FUN(ts, t)))],
    typeOfBuildConsTerms(s, trms) == (trms', ts).
    
  typeOfBuildTerm(s, CastTerm(e, t1, t2)) = (CastTerm(e, t1, t2), t). // Silence CastTerm
  
  // BUILD TERMS WITHIN CONSTRUCTORS
  typeOfBuildConsTerm: scope * Term -> (Term * TYPE)
  typeOfBuildConsTerms: scope * list(Term) -> (list(Term) * list(TYPE))
  
  typeOfBuildConsTerm(s, Var(x)) = (trm, t) :- {p d t'}
  	typeOfVar of Var{x@x} in s |-> [(p, (d, t'))],
   	cast(Var(x), t', t) == trm.
  
  typeOfBuildConsTerm(s, term) = typeOfBuildTerm(s, term).
  
  typeOfBuildConsTerms(s, [term]) = ([trm], [ty]) :-
  	typeOfBuildConsTerm(s, term) == (trm, ty).
  	
  typeOfBuildConsTerms(s, [hd|terms]) = ([hd'|terms'], [t|types]) :-
    typeOfBuildConsTerm(s, hd) == (hd', t),
    typeOfBuildConsTerms(s, terms) == (terms', types).
  
rules // insertTypeChecks

  insertTypeCheckSection : Section -> Section
  insertTypeCheckSections maps insertTypeCheckSection(list(*)) = *
  
  insertTypeCheckSection(Signature(sigSec)) = Strategies([castVal|rs]) :-
    castVal == CastValStrat(),
    insertTypeCheckSigSections(sigSec) == rs.
  
  insertTypeCheckSection(Rules(rs)) = nil.
  
  insertTypeCheckSigSection : SigSection -> list(Def)
  insertTypeCheckSigSections maps insertTypeCheckSigSection(list(*)) = *
  
  insertTypeCheckSigSection(Sorts(sorts)) = nil.
  insertTypeCheckSigSection(Constructors(cons)) = def :-
    insertTypeCheckCons(cons) == def.
    
  insertTypeCheckCon : OpDecl -> Def
  insertTypeCheckCons maps insertTypeCheckCon(list(*)) = list(*)
  
  insertTypeCheckCon(OpDecl(c, FunType(srts, ConstType(SortNoArgs(typ))))) = SDefTypeCheck(typ, c, srts).
