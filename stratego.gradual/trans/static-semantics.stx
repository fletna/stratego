module static-semantics

signature
  sorts Section SigSection Module OpDecl Sort Rule Term Type Def
        ConstType
  constructors
    Module       : string * list(Section) -> Module
    Signature    : list(SigSection) -> Section
    Sorts        : list(Sort) -> SigSection
    Constructors : list(OpDecl) -> SigSection
    OpDecl       : string * Type -> OpDecl
    FunType      : list(Type) * Type -> Type
    ConstType    : Sort -> Type
    SortNoArgs   : string -> Sort
    Rules        : list(Def) -> Section
    RDefNoArgs   : string * Rule -> Def
    Rule         : Term * Term * list(string) -> Rule
    NoAnnoList   : Term -> Term
    Var          : string -> Term
    Op           : string * list(Term) -> Term
    
  sorts TYPE
  constructors
    SRT : occurrence -> TYPE
    FUN : list(TYPE) * TYPE -> TYPE
    DYN : TYPE
  
  namespaces
    Sort : string
    Cons : string
    Var : string
    Rule : string
    
  relations
    typeOfSort : occurrence -> TYPE
    typeOfCons : occurrence -> TYPE
    typeOfVar  : occurrence -> TYPE
    typeOfTerm : occurrence -> TYPE
    typeOfRule : occurrence -> TYPE
    
  name-resolution 
    labels P

rules 

  insertCasts : Module -> Module
  
  insertCasts(m) = m' :- moduleOkC(m) == m'.
    
rules moduleOk : Module 

  moduleOk(m) :- {m'} moduleOkC(m) == m'.

  moduleOkC : Module -> Module

  moduleOkC(Module(x, sections)) = Module(x, sections') :- {s}
    new s,
    sectionsOk(s, sections) == sections'.

rules 

  sectionOk  : scope * Section -> Section
  sectionsOk maps sectionOk(*, list(*)) = list(*)
  

rules // signatures
  
  sectionOk(s, Signature(sigsections)) = Signature(sigsections') :-
    sigSectionsOk(s, sigsections) == sigsections'.
  
  sigSectionOk: scope * SigSection -> SigSection
  sigSectionsOk maps sigSectionOk(*, list(*)) = list(*)
  
  sigSectionOk(s, Sorts(srts)) = Sorts(srts) :- 
    sortsOk(s, srts).
  
  sortOk : scope * Sort 
  sortsOk maps sortOk(*, list(*)) 
  
  sortOk(s, SortNoArgs(srt)) :- {d}
    d == Sort{srt@srt},
    s -> d with typeOfSort SRT(d).
  
  sigSectionOk(s, Constructors(cdecls)) = Constructors(cdecls) :- 
    consDeclsOk(s, cdecls).
    
  consDeclOk : scope * OpDecl
  consDeclsOk maps consDeclOk(*, list(*))
  
  consDeclOk(s, OpDecl(c, FunType(srts, srt))) :- {ts t}
    typeOfSorts(s, srts) == ts,
    typeOfSort(s, srt) == t,
    s -> Cons{c@c} with typeOfCons FUN(ts, t).
  
  typeOfSort : scope * Type -> TYPE
  typeOfSorts maps typeOfSort(*, list(*)) = list(*)
  
  typeOfSort(s, ConstType(SortNoArgs(srt))) = t :- {p d}
    typeOfSort of Sort{srt@srt} in s |-> [(p, (d, t))].    
  
rules // rules 

  sectionOk(s, Rules(rs)) = Rules(rs') :- 
    rulesOk(s, rs) == rs'.
  
  ruleOk : scope * Def -> Def
  rulesOk maps ruleOk(*, list(*)) = list(*)
  
  ruleOk(s, RDefNoArgs(f, Rule(trm1, trm2, cond))) = RDefNoArgs(f, Rule(trm1, trm2, cond))  :- {s_r t1 t2}
    new s_r, s_r -P-> s,
    typeOfMatchTerm(s_r, trm1) == t1,
    typeOfBuildTerm(s_r, trm2) == t2,
    s -> Rule{f@f} with typeOfRule FUN([t1], t2).
  
  
  typeOfMatchTerm : scope * Term -> TYPE
  typeOfMatchTerms maps typeOfMatchTerm(*, list(*)) = list(*)
  
  typeOfMatchTerm(s, NoAnnoList(term)) = t :-
    typeOfMatchTerm(s, term) == t.
  
  typeOfMatchTerm(s, Var(x)) = t :-
   s -> Var{x@x} with typeOfVar t.
  
  typeOfMatchTerm(s, Op(c, trms)) = t :- {p d ts}
    typeOfCons of Cons{c@c} in s |-> [(p, (d, FUN(ts, t)))],
    typeOfMatchTerms(s, trms) == ts.

  typeOfBuildTerm : scope * Term -> TYPE
  typeOfBuildTerms maps typeOfBuildTerm(*, list(*)) = list(*)
  
  typeOfBuildTerm(s, NoAnnoList(term)) = t :-
    typeOfBuildTerm(s, term) == t.
  
  typeOfBuildTerm(s, Var(x)) = t :- {p d t'}
   typeOfVar of Var{x@x} in s |-> [(p, (d, t'))],
   t == t'.

  typeOfBuildTerm(s, Op(c, trms)) = t :- {p d ts}
    typeOfCons of Cons{c@c} in s |-> [(p, (d, FUN(ts, t)))],
    typeOfBuildTerms(s, trms) == ts.
//    
//  insertCastTrm : TYPE * TYPE * Term -> Term 
//  
//  insertCastTrm(t, t, trm) = trm.
//  
//  insertCastTrm(DYN(), t, trm) = trm. 
    // todo : create call to cast/check strategy for t
    
